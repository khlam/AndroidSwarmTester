package a
import "b"
var _ = b.UsePackage
var Var1175 = func(Param1206 complex64, Param1207 [2]complex128, Param1208 interface{})[]*int {
select {
}
Var1473 := [1][2][2]*[]**map[byte]func(complex128,bool,int16,rune) (rune,int16,uintptr){}
Var1554 := (*int)(nil)
Var1646 := [2]**interface {  Method1302 (interface{},complex64) rune
 Method1303 (int16,complex128,int16,interface{}) (float64,byte,complex64)
}{}
Var1509 := [1][0]uint{}
Var1266 := make(chan [1]func(interface{},float64) map[interface{}]int ,Var1267)
Var1644 := [2]rune{}
(((<- Var1266))[(<- (*(b.Var1279)))](Param1208,(([2]func(interface {  Method1280 (func(uint) (complex64,complex64)) (complex64,map[int16]string,map[float64]float64)
},chan chan complex128) float64{})[(<- make(chan int ))](interface {  Method1280 (func(uint) (complex64,complex64)) (complex64,map[int16]string,map[float64]float64)
}(nil),make(chan chan complex128 ,1))) + (1.0)))[interface{}(nil)] ++
Var1367 := (*((*(((*((((Var1473)[(int)(((Var1509)[((*(Var1554))) - (1)])[((func(byte,interface { },[]struct { Field1615 rune
},uint) int)(nil))(byte(0),interface { }(nil),[]struct { Field1615 rune
}{},uint(1))] )])[(int)((Var1644)[(Var1267) + (1)] )])[(Var1645)[((func(bool,*complex64,[2]interface { }) int)(nil))(false,(*complex64)(nil),[2]interface { }{})]])))[(<- make(chan int ,1))]))))
Var1787 := (*complex64)(nil)
Var1788 := [0]chan float64{}
Var1367,(*((Var1646)[((func(float32,*float32,uintptr,complex64) int)(nil))(float32(1.0),(*float32)(nil),uintptr(0),complex64(1i))])),(*((([][1]*interface { }{})[(<- make(chan int ,1))])[([]int{})[(int)(([]float64{})[((func(chan byte,float64,func(int) (float32,int)) int)(nil))(make(chan byte ),1.0,((func(int) (float32,int))(nil)))] ,)]])),(*(Var1787)) = map[byte]func(complex128,bool,int16,rune) (rune,int16,uintptr){},(*interface {  Method1302 (interface{},complex64) rune
 Method1303 (int16,complex128,int16,interface{}) (float64,byte,complex64)
})(nil),interface { }(nil),complex64(1i)
SINK = Var1788
switch COND := (interface{})((([]struct { Field1853 uintptr
Field1854 [1]error
Field1855 rune
Field1856 float32
}{})[(int)((len)((*(([]*string{})[(int)(((([][0][2]int16{})[(Var1267) + (1)])[(Var1267) + (1)])[(([]int{})[((func(uintptr,map[chan bool]struct { }) int)(nil))(uintptr(0),make(map[chan bool]struct { } ,1))]) + (1)] )]))))]).Field1856); COND.(type) {
case int16:
make(chan complex128 ,1) <- 1i
switch COND := (interface{})(([]func(uint,byte,map[error]complex128) (interface{},complex128,interface { }){})[(int)((cap)(([][]interface{}{})[((func(interface {  Method1917 ([2]error,struct { },byte,interface {  Method1918 (uint,error,int16,int) (float64,complex64)
 Method1919 (int,int16) (error,rune,float64)
 Method1920 (complex128) (float64,bool)
}) (string,func(rune) (byte,float32),interface {  Method1921 (error,float32) (int,byte)
 Method1922 (byte,complex64) (complex64,int16,string)
})
 Method1923 (error,[2]int16,map[rune]complex64) int
},chan func(rune,complex64,interface{}) (int,complex128)) int)(nil))(interface {  Method1917 ([2]error,struct { },byte,interface {  Method1918 (uint,error,int16,int) (float64,complex64)
 Method1919 (int,int16) (error,rune,float64)
 Method1920 (complex128) (float64,bool)
}) (string,func(rune) (byte,float32),interface {  Method1921 (error,float32) (int,byte)
 Method1922 (byte,complex64) (complex64,int16,string)
})
 Method1923 (error,[2]int16,map[rune]complex64) int
}(nil),make(chan func(rune,complex64,interface{}) (int,complex128) ))]))]); COND.(type) {
case chan byte:
default:
}
default:
}
_ = Var1473
_ = Var1554
_ = Var1646
_ = Var1509
_ = Var1266
_ = Var1644
_ = Var1367
_ = Var1787
_ = Var1788
_ = Param1206
_ = Param1207
_ = Param1208
return []*int{}
}(complex64(1i),[2]complex128{},interface{}(nil))
var Var284 = (**chan struct { Field269 int
Field270 [0]float64
Field271 []bool
})(nil)
var Var47 = (**int)(nil)
